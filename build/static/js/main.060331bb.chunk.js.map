{"version":3,"sources":["useWebcam.js","useModel.js","useBoxRenderer.js","index.js","styles.module.css"],"names":["useWebcam","videoRef","_useState","useState","_useState2","Object","slicedToArray","webcamLoaded","setWebcamLoaded","useEffect","navigator","mediaDevices","getUserMedia","audio","video","facingMode","then","stream","current","srcObject","onloadedmetadata","useModel","modelPath","model","setModel","objectDetector","load","renderPredictions","predictions","canvasRef","ctx","getContext","clearRect","canvas","width","height","font","textBaseline","forEach","prediction","timer","x","bbox","y","fillStyle","fillText","scoreText","score","toFixed","class","getLabelText","clearTimeout","el","document","getElementById","classList","contains","add","speakWarn","setTimeout","remove","synth","window","speechSynthesis","pitch","utter","SpeechSynthesisUtterance","lang","speak","detectFrame","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","detect","sent","requestAnimationFrame","stop","_x","_x2","_x3","apply","this","arguments","useBoxRenderer","shouldRender","App","useRef","cameraLoaded","react_default","createElement","style","textAlign","fontSize","className","styles","fixed","autoPlay","playsInline","muted","ref","rootElement","ReactDOM","render","module","exports"],"mappings":"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","file":"static/js/main.060331bb.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\n\nconst useWebcam = videoRef => {\n  const [webcamLoaded, setWebcamLoaded] = useState(false)\n  useEffect(() => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user'\n          }\n        })\n        .then(stream => {\n          // window.stream = stream\n          videoRef.current.srcObject = stream\n          videoRef.current.onloadedmetadata = () => {\n            setWebcamLoaded(true)\n          }\n        })\n    }\n  }, [videoRef])\n  return webcamLoaded\n}\n\nexport default useWebcam\n","import { useEffect, useState } from 'react'\n\nimport objectDetector from '@cloud-annotations/object-detection'\n\nconst useModel = modelPath => {\n  const [model, setModel] = useState()\n  useEffect(() => {\n    objectDetector.load(modelPath).then(model => {\n      setModel(model)\n    })\n  }, [modelPath])\n  return model\n}\n\nexport default useModel\n","import { useEffect } from 'react'\n\nconst SCORE_DIGITS = 4\nlet hasSpeak = false;\n\nconst getLabelText = (prediction) => {\n    const scoreText = prediction.score.toFixed(SCORE_DIGITS)\n    return prediction.class + ', score: ' + scoreText\n}\n\nconst renderPredictions = (predictions, canvasRef) => {\n  const ctx = canvasRef.current.getContext('2d')\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  // Font options.\n  const font = '16px sans-serif'\n  ctx.font = font\n  ctx.textBaseline = 'top'\n  // predictions.forEach(prediction => {\n  //   const x = prediction.bbox[0]\n  //   const y = prediction.bbox[1]\n  //   const width = prediction.bbox[2]\n  //   const height = prediction.bbox[3]\n  //   // Draw the bounding box.\n  //   ctx.strokeStyle = '#00FFFF'\n  //   ctx.lineWidth = 4\n  //   ctx.strokeRect(x, y, width, height)\n  //   // Draw the label background.\n  //   ctx.fillStyle = '#00FFFF'\n  //   const textWidth = ctx.measureText(getLabelText(prediction)).width\n  //   const textHeight = parseInt(font, 10) // base 10\n  //   ctx.fillRect(x, y, textWidth + 4, textHeight + 4)\n  // })\n\n  predictions.forEach(prediction => {\n    var timer;\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    // Draw the text last to ensure it's on top.\n    ctx.fillStyle = '#000000'\n    ctx.fillText(getLabelText(prediction), x, y)\n    clearTimeout(timer);\n    if(prediction.class===\"Touch-Face\"){\n      \n      let el = document.getElementById(\"js-body\");\n      if(!el.classList.contains(\"error\")){\n        el.classList.add(\"error\");\n        speakWarn();\n        timer = setTimeout(function(){\n          el.classList.remove(\"error\");\n        },1500)\n      }\n     \n      //speakWarn();\n\n    }\n  })\n}\nconst speakWarn = () =>{\n  const synth = window.speechSynthesis\n  synth.pitch = 8;\n  //synth.rate = 10;\n  \n  const utter = new SpeechSynthesisUtterance(\"Don't touch your face\")\n  //const voices = speechSynthesis.getVoices()\n  \n  utter.lang = 'en-EN';\n  utter.pitch = 1;\n\n  synth.speak(utter);\n}\n\nconst detectFrame = async (model, videoRef, canvasRef) => {\n  const predictions = await model.detect(videoRef.current)\n  renderPredictions(predictions, canvasRef)\n  requestAnimationFrame(() => {\n    detectFrame(model, videoRef, canvasRef)\n  })\n}\n\nconst useBoxRenderer = (model, videoRef, canvasRef, shouldRender) => {\n  useEffect(() => {\n    if (model && shouldRender) {\n      detectFrame(model, videoRef, canvasRef)\n    }\n  }, [canvasRef, model, shouldRender, videoRef])\n}\n\nexport default useBoxRenderer\n","import React, { useRef } from 'react'\nimport ReactDOM from 'react-dom'\n\nimport useWebcam from './useWebcam'\nimport useModel from './useModel'\nimport useBoxRenderer from './useBoxRenderer'\n\n\nimport styles from './styles.module.css'\n\nconst MODEL_PATH = process.env.PUBLIC_URL + '/model_web'\n\nconst App = () => {\n  const videoRef = useRef()\n  const canvasRef = useRef()\n\n  const cameraLoaded = useWebcam(videoRef)\n  const model = useModel(MODEL_PATH)\n  useBoxRenderer(model, videoRef, canvasRef, cameraLoaded)\n  \n  return (\n    <div>\n      <h2 style={{textAlign:'center',fontSize:'3em'}}>VICTOR 's PROJECT</h2>  \n      <video\n        className={styles.fixed}\n        autoPlay\n        playsInline\n        muted\n        ref={videoRef}\n        width=\"800\"\n        height=\"600\"\n      />\n      <canvas\n        className={styles.fixed}\n        ref={canvasRef}\n        width=\"800\"\n        height=\"600\"\n      />\n      {/* <button onClick={()=>speakTest()} > Click</button>  */}\n     \n    </div>\n  )\n}\n\nconst rootElement = document.getElementById('root')\nReactDOM.render(<App />, rootElement)\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"fixed\":\"styles_fixed__v-bnh\"};"],"sourceRoot":""}